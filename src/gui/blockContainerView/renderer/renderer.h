#ifndef renderer_h
#define renderer_h

#include <vector>

typedef unsigned int ElementID;

#include "middleEnd/blockContainerWrapper.h"
#include "../viewManager/viewManager.h"
#include "color.h"
#include "elementCreator.h"
class ElementCreator;



// This is the renderer interface. It defines all the methods that non-windowing
// or renderer-specific code should be able to call. Each implementation is
// responsible for defining a render function and calling it in a loop.

// Under Construction Notes -----
// placeholder system for submitting sprites using BlockType, not sure how they
// will be handled
//
// more effects will be added. maybe for submitting circles and stuff
// it might be cool if tints could fade out too
//
// the final version will not take a viewmanager pointer. That argument will
// be replaced with a view matrix generated by the viewmanager

class Renderer {
public:
    // main flow
    virtual void setBlockContainer(BlockContainerWrapper* blockContainer) = 0;
    // virtual void setSimulator(Simulator* simulator) = 0;

    ElementCreator getElementCreator() {return ElementCreator(this);}

    virtual void updateView(ViewManager* viewManager) = 0;
    // virtual void updateBlockContainer(Difference diff) = 0;

    // effect layer
    virtual ElementID addLine(const std::vector<FPosition>& positions, float width) = 0;
    virtual void removeLine(ElementID id) = 0;

    virtual ElementID addTint(Position position, Color color) = 0;
    virtual ElementID addTint(FPosition start, float width, float height, Color color) = 0;
    virtual void removeTint(ElementID id) = 0;

    virtual ElementID addBlockPreview(Position position, Rotation rotation, Color modulate, float alpha) = 0;
    virtual void removeBlockPreview(ElementID id) = 0;

    virtual ElementID addConnectionPreview(std::pair<FPosition, FPosition> positions, Color modulate, float alpha) = 0;
    virtual void removeConnectionPreview(ElementID id) = 0;
    
    virtual void addConfetti(FPosition start) = 0;
};

#endif /* renderer_h */
